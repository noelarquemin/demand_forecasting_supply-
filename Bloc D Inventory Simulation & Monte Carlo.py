# -*- coding: utf-8 -*-
"""Untitled65.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BgjgYUdY6fMgFrC3XxZzrkBupiGkGu38
"""

"""
DEMAND FORECASTING & INVENTORY SIMULATION - SUPPLY CHAIN
Block D: Inventory Simulation & Monte Carlo
"""

# ============================================================================
# IMPORTS (Additional for Block D)
# ============================================================================
from collections import deque
from tqdm import tqdm
import warnings
warnings.filterwarnings('ignore')

print("\n" + "=" * 80)
print("BLOCK D: INVENTORY SIMULATION & MONTE CARLO")
print("=" * 80)

# ============================================================================
# 1. SAFETY STOCK AND REORDER POINT CALCULATION
# ============================================================================
print("\n[1] CALCULATING SAFETY STOCK AND REORDER POINTS...")

# Service level by ABC class (z-score for normal distribution)
service_level_z = {
    'A': 1.28,  # 90% service level
    'B': 1.06,  # 85% service level
    'C': 0.84   # 80% service level
}

print("\nService Level Targets by ABC Class:")
for abc_class, z_value in service_level_z.items():
    service_pct = {1.28: 90, 1.06: 85, 0.84: 80}[z_value]
    print(f"  Class {abc_class}: {service_pct}% (z = {z_value})")

# Calculate safety stock and ROP per SKU
print("\n[1.1] Computing Safety Stock per SKU...")

# Get SKU-level parameters
sku_params = df.groupby('SKU_ID').agg({
    'Units_Sold': ['mean', 'std'],
    'Supplier_Lead_Time_Days': 'mean',
    'Order_Quantity': 'mean',
    'Reorder_Point': 'mean',
    'Unit_Cost': 'mean',
    'Unit_Price': 'mean',
    'ABC_Class': 'first',
    'XYZ_Class': 'first',
    'Supplier_ID': 'first'
}).reset_index()

# Flatten column names
sku_params.columns = ['SKU_ID', 'avg_demand', 'std_demand', 'avg_lead_time',
                      'avg_order_qty', 'dataset_rop', 'unit_cost', 'unit_price',
                      'ABC_Class', 'XYZ_Class', 'Supplier_ID']

# Map z-score based on ABC class
sku_params['z_score'] = sku_params['ABC_Class'].map(service_level_z)

# Calculate safety stock: z × σ_demand × √lead_time
sku_params['safety_stock'] = (
    sku_params['z_score'] *
    sku_params['std_demand'] *
    np.sqrt(sku_params['avg_lead_time'])
)

# Round to integers
sku_params['safety_stock'] = sku_params['safety_stock'].fillna(0).round().astype(int)
sku_params['avg_order_qty'] = sku_params['avg_order_qty'].round().astype(int)

print(f"Safety stock calculated for {len(sku_params)} SKUs")

# ============================================================================
# 2. REORDER POINT CALCULATION
# ============================================================================
print("\n[2] CALCULATING REORDER POINTS...")

# Parameter: use dataset ROP or calculate
use_dataset_ROP = False

if use_dataset_ROP:
    print("Using dataset Reorder_Point values...")
    sku_params['reorder_point'] = sku_params['dataset_rop'].round().astype(int)
else:
    print("Calculating Reorder_Point: avg_demand × lead_time + safety_stock...")
    sku_params['reorder_point'] = (
        sku_params['avg_demand'] * sku_params['avg_lead_time'] +
        sku_params['safety_stock']
    ).round().astype(int)

print(f"Reorder points calculated")

# ============================================================================
# 3. REORDER QUANTITY LOGIC
# ============================================================================
print("\n[3] SETTING REORDER QUANTITY LOGIC...")

# Parameter: use dataset Order_Quantity or calculate
use_dataset_order_qty = True

if use_dataset_order_qty:
    print("Using dataset Order_Quantity values...")
    sku_params['reorder_quantity'] = sku_params['avg_order_qty']
else:
    print("Calculating reorder_quantity: 0.5 × mean(Order_Quantity)...")
    sku_params['reorder_quantity'] = (sku_params['avg_order_qty'] * 0.5).round().astype(int)

print(f"Reorder quantities set")

# ============================================================================
# 4. PREPARE SIMULATION DATA
# ============================================================================
print("\n[4] PREPARING SIMULATION DATA...")

# Get initial inventory levels (first day of test period)
initial_inventory = df[df['Date'] == split_date].groupby('SKU_ID')['Inventory_Level'].first().reset_index()
initial_inventory.columns = ['SKU_ID', 'initial_inventory']

sku_params = sku_params.merge(initial_inventory, on='SKU_ID', how='left')
sku_params['initial_inventory'] = sku_params['initial_inventory'].fillna(
    sku_params['reorder_point'] * 2
).round().astype(int)

print(f"Initial inventory set for {len(sku_params)} SKUs")

# Get supplier lead time distributions
print("\n[4.1] Building Supplier Lead Time Distributions...")
supplier_leadtime_dist = {}
for supplier_id in df['Supplier_ID'].unique():
    lead_times = df[df['Supplier_ID'] == supplier_id]['Supplier_Lead_Time_Days'].dropna().values
    if len(lead_times) > 0:
        supplier_leadtime_dist[supplier_id] = lead_times
    else:
        supplier_leadtime_dist[supplier_id] = np.array([7])

print(f"Lead time distributions created for {len(supplier_leadtime_dist)} suppliers")

# Get unique SKUs
unique_skus = sku_params['SKU_ID'].unique()

# ============================================================================
# 5. INVENTORY SIMULATION FUNCTION
# ============================================================================
print("\n[5] DEFINING INVENTORY SIMULATION FUNCTION...")

def simulate_inventory(sku_id, demand_forecast, sku_info, supplier_lead_dist,
                       use_monte_carlo=False, noise_std=None):
    """
    Simulate inventory for a single SKU over the forecast horizon
    """

    # Initialize parameters
    on_hand = sku_info['initial_inventory']
    reorder_point = sku_info['reorder_point']
    order_quantity = sku_info['reorder_quantity']

    # Track orders (FIFO queue)
    order_queue = deque()

    # Results tracking
    daily_inventory = []
    daily_demand_actual = []
    daily_served = []
    daily_unmet = []
    daily_stockout_flag = []
    orders_placed = []
    orders_received = []

    # Simulation loop
    for day_idx, forecast_demand in enumerate(demand_forecast):

        # 1. Receive orders arriving today
        received_today = 0
        while order_queue and order_queue[0][0] == day_idx:
            arrival_day, qty = order_queue.popleft()
            on_hand += qty
            received_today += qty

        orders_received.append(received_today)

        # 2. Determine actual demand
        if use_monte_carlo and noise_std is not None:
            noise = np.random.normal(0, noise_std)
            actual_demand = max(0, forecast_demand + noise)
        else:
            actual_demand = forecast_demand

        actual_demand = int(round(actual_demand))

        # 3. Fulfill demand
        served = min(on_hand, actual_demand)
        unmet = max(0, actual_demand - on_hand)
        stockout = 1 if unmet > 0 else 0

        # Update inventory
        on_hand = max(0, on_hand - served)

        # 4. Check if reorder needed
        order_placed = 0
        if on_hand <= reorder_point:
            if use_monte_carlo:
                lead_time = int(np.ceil(np.random.choice(supplier_lead_dist)))
            else:
                lead_time = int(round(sku_info['avg_lead_time']))

            arrival_day = day_idx + lead_time
            order_queue.append((arrival_day, order_quantity))
            order_placed = order_quantity

        # 5. Record results
        daily_inventory.append(on_hand)
        daily_demand_actual.append(actual_demand)
        daily_served.append(served)
        daily_unmet.append(unmet)
        daily_stockout_flag.append(stockout)
        orders_placed.append(order_placed)

    # Calculate KPIs
    total_demand = sum(daily_demand_actual)
    total_served = sum(daily_served)
    total_unmet = sum(daily_unmet)

    fill_rate = (total_served / (total_demand + 1e-10)) * 100
    stockout_rate = (sum(daily_stockout_flag) / len(daily_stockout_flag)) * 100

    # Costs
    annual_storage_rate = 0.20
    unit_storage_cost = sku_info['unit_cost'] * (annual_storage_rate / 365)
    holding_cost = sum(daily_inventory) * unit_storage_cost

    penalty_factor = 1.5
    unit_margin = sku_info['unit_price'] - sku_info['unit_cost']
    unit_stockout_cost = unit_margin * penalty_factor
    stockout_cost = total_unmet * unit_stockout_cost

    total_cost = holding_cost + stockout_cost

    results = {
        'SKU_ID': sku_id,
        'fill_rate': fill_rate,
        'stockout_rate': stockout_rate,
        'holding_cost': holding_cost,
        'stockout_cost': stockout_cost,
        'total_cost': total_cost,
        'total_demand': total_demand,
        'total_served': total_served,
        'total_unmet': total_unmet,
        'avg_inventory': np.mean(daily_inventory),
        'orders_placed_count': sum([1 for x in orders_placed if x > 0])
    }

    return results

print("Inventory simulation function defined")

# ============================================================================
# 6. XGBOOST FORECAST SIMULATION j+1 (DETERMINISTIC)
# ============================================================================
print("\n" + "=" * 80)
print("[6] XGBOOST j+1 FORECAST SIMULATION (Deterministic)")
print("=" * 80)

print("\nRunning XGBoost j+1 forecast simulation...")

xgb_sim_results = []

for sku_id in tqdm(unique_skus, desc="XGBoost j+1 Sim"):
    sku_data = test_df_clean[test_df_clean['SKU_ID'] == sku_id].sort_values('Date')

    if len(sku_data) == 0:
        continue

    sku_info_row = sku_params[sku_params['SKU_ID'] == sku_id]
    if len(sku_info_row) == 0:
        continue
    sku_info_row = sku_info_row.iloc[0]

    supplier_id = sku_info_row['Supplier_ID']
    supplier_lead_dist = supplier_leadtime_dist.get(supplier_id, np.array([7]))

    sku_info = {
        'initial_inventory': sku_info_row['initial_inventory'],
        'reorder_point': sku_info_row['reorder_point'],
        'reorder_quantity': sku_info_row['reorder_quantity'],
        'avg_lead_time': sku_info_row['avg_lead_time'],
        'unit_cost': sku_info_row['unit_cost'],
        'unit_price': sku_info_row['unit_price']
    }

    demand_forecast = sku_data['Pred_XGB_j1'].fillna(0).values

    result = simulate_inventory(
        sku_id=sku_id,
        demand_forecast=demand_forecast,
        sku_info=sku_info,
        supplier_lead_dist=supplier_lead_dist,
        use_monte_carlo=False
    )

    result['ABC_Class'] = sku_info_row['ABC_Class']
    result['XYZ_Class'] = sku_info_row['XYZ_Class']
    xgb_sim_results.append(result)

xgb_sim_df = pd.DataFrame(xgb_sim_results)

print(f"\nXGBoost j+1 simulation complete: {len(xgb_sim_df)} SKUs")

# ============================================================================
# 7. XGBOOST FORECAST SIMULATION j+7 (DETERMINISTIC)
# ============================================================================
print("\n" + "=" * 80)
print("[7] XGBOOST j+7 FORECAST SIMULATION (Deterministic)")
print("=" * 80)

print("\nRunning XGBoost j+7 forecast simulation...")

xgb_j7_sim_results = []

for sku_id in tqdm(unique_skus, desc="XGBoost j+7 Sim"):
    sku_data = test_df_clean[test_df_clean['SKU_ID'] == sku_id].sort_values('Date')

    if len(sku_data) == 0:
        continue

    sku_info_row = sku_params[sku_params['SKU_ID'] == sku_id]
    if len(sku_info_row) == 0:
        continue
    sku_info_row = sku_info_row.iloc[0]

    supplier_id = sku_info_row['Supplier_ID']
    supplier_lead_dist = supplier_leadtime_dist.get(supplier_id, np.array([7]))

    sku_info = {
        'initial_inventory': sku_info_row['initial_inventory'],
        'reorder_point': sku_info_row['reorder_point'],
        'reorder_quantity': sku_info_row['reorder_quantity'],
        'avg_lead_time': sku_info_row['avg_lead_time'],
        'unit_cost': sku_info_row['unit_cost'],
        'unit_price': sku_info_row['unit_price']
    }

    # Use j+7 predictions
    demand_forecast = sku_data['Pred_XGB_j7'].fillna(0).values

    result = simulate_inventory(
        sku_id=sku_id,
        demand_forecast=demand_forecast,
        sku_info=sku_info,
        supplier_lead_dist=supplier_lead_dist,
        use_monte_carlo=False
    )

    result['ABC_Class'] = sku_info_row['ABC_Class']
    result['XYZ_Class'] = sku_info_row['XYZ_Class']
    xgb_j7_sim_results.append(result)

xgb_j7_sim_df = pd.DataFrame(xgb_j7_sim_results)

print(f"\nXGBoost j+7 simulation complete: {len(xgb_j7_sim_df)} SKUs")

# 7.5. XGBOOST FORECAST SIMULATION j+14 (DETERMINISTIC)
# ============================================================================
print("\n[7.5] XGBOOST j+14 FORECAST SIMULATION...")

xgb_j14_sim_results = []

for sku_id in tqdm(unique_skus, desc="XGBoost j+14 Sim"):
    sku_data = test_df_clean[test_df_clean['SKU_ID'] == sku_id].sort_values('Date')

    if len(sku_data) == 0:
        continue

    sku_info_row = sku_params[sku_params['SKU_ID'] == sku_id]
    if len(sku_info_row) == 0:
        continue
    sku_info_row = sku_info_row.iloc[0]

    supplier_id = sku_info_row['Supplier_ID']
    supplier_lead_dist = supplier_leadtime_dist.get(supplier_id, np.array([7]))

    sku_info = {
        'initial_inventory': sku_info_row['initial_inventory'],
        'reorder_point': sku_info_row['reorder_point'],
        'reorder_quantity': sku_info_row['reorder_quantity'],
        'avg_lead_time': sku_info_row['avg_lead_time'],
        'unit_cost': sku_info_row['unit_cost'],
        'unit_price': sku_info_row['unit_price']
    }

    demand_forecast = sku_data['Pred_XGB_j14'].fillna(0).values

    result = simulate_inventory(
        sku_id=sku_id,
        demand_forecast=demand_forecast,
        sku_info=sku_info,
        supplier_lead_dist=supplier_lead_dist,
        use_monte_carlo=False
    )

    result['ABC_Class'] = sku_info_row['ABC_Class']
    result['XYZ_Class'] = sku_info_row['XYZ_Class']
    xgb_j14_sim_results.append(result)

xgb_j14_sim_df = pd.DataFrame(xgb_j14_sim_results)

print(f"XGBoost j+14 simulation complete: {len(xgb_j14_sim_df)} SKUs")

# ============================================================================
# 8. MONTE CARLO SIMULATION SETUP
# ============================================================================
print("\n" + "=" * 80)
print("[8] MONTE CARLO SIMULATION")
print("=" * 80)

print("\n[8.1] Selecting SKUs for Monte Carlo...")

# Identify top SKUs by revenue
sku_revenue_for_mc = xgb_sim_df.merge(
    sku_params[['SKU_ID', 'unit_price']],
    on='SKU_ID',
    how='left'
)
sku_revenue_for_mc['revenue'] = sku_revenue_for_mc['total_demand'] * sku_revenue_for_mc['unit_price']
sku_revenue_for_mc = sku_revenue_for_mc.sort_values('revenue', ascending=False)

# Scaling parameters
n_top_skus = 100
n_mc_top = 1000
n_mc_other = 200

# Select top SKUs
top_skus = sku_revenue_for_mc.head(n_top_skus)['SKU_ID'].values
other_skus = sku_revenue_for_mc.iloc[n_top_skus:]['SKU_ID'].values

print(f"\nTop {len(top_skus)} SKUs selected for full Monte Carlo ({n_mc_top} runs)")
print(f"Remaining {len(other_skus)} SKUs will use reduced Monte Carlo ({n_mc_other} runs)")

# ============================================================================
# 9. MONTE CARLO SIMULATION EXECUTION
# ============================================================================
print("\n[9] RUNNING MONTE CARLO SIMULATION...")

def run_monte_carlo_sku(sku_id, n_runs, use_xgb=True):
    """Run Monte Carlo simulation for a single SKU"""

    sku_data = test_df_clean[test_df_clean['SKU_ID'] == sku_id].sort_values('Date')

    if len(sku_data) == 0:
        return None

    sku_info_row = sku_params[sku_params['SKU_ID'] == sku_id]
    if len(sku_info_row) == 0:
        return None
    sku_info_row = sku_info_row.iloc[0]

    supplier_id = sku_info_row['Supplier_ID']
    supplier_lead_dist = supplier_leadtime_dist.get(supplier_id, np.array([7]))

    sku_info = {
        'initial_inventory': sku_info_row['initial_inventory'],
        'reorder_point': sku_info_row['reorder_point'],
        'reorder_quantity': sku_info_row['reorder_quantity'],
        'avg_lead_time': sku_info_row['avg_lead_time'],
        'unit_cost': sku_info_row['unit_cost'],
        'unit_price': sku_info_row['unit_price']
    }

    if use_xgb:
        base_forecast = sku_data['Pred_XGB_j1'].fillna(0).values
    else:
        base_forecast = sku_data['Units_Sold'].values

    noise_std = sku_info_row['std_demand']

    mc_results = []
    for _ in range(n_runs):
        result = simulate_inventory(
            sku_id=sku_id,
            demand_forecast=base_forecast,
            sku_info=sku_info,
            supplier_lead_dist=supplier_lead_dist,
            use_monte_carlo=True,
            noise_std=noise_std
        )
        mc_results.append(result)

    mc_df = pd.DataFrame(mc_results)

    aggregated = {
        'SKU_ID': sku_id,
        'fill_rate_mean': mc_df['fill_rate'].mean(),
        'fill_rate_std': mc_df['fill_rate'].std(),
        'fill_rate_p5': mc_df['fill_rate'].quantile(0.05),
        'fill_rate_p95': mc_df['fill_rate'].quantile(0.95),
        'stockout_rate_mean': mc_df['stockout_rate'].mean(),
        'stockout_rate_std': mc_df['stockout_rate'].std(),
        'total_cost_mean': mc_df['total_cost'].mean(),
        'total_cost_std': mc_df['total_cost'].std(),
        'total_cost_p5': mc_df['total_cost'].quantile(0.05),
        'total_cost_p95': mc_df['total_cost'].quantile(0.95),
        'holding_cost_mean': mc_df['holding_cost'].mean(),
        'stockout_cost_mean': mc_df['stockout_cost'].mean(),
        'total_demand_mean': mc_df['total_demand'].mean(),
        'ABC_Class': sku_info_row['ABC_Class'],
        'XYZ_Class': sku_info_row['XYZ_Class']
    }

    return aggregated

# Run Monte Carlo for top SKUs
print(f"\n[9.1] Monte Carlo for Top {len(top_skus)} SKUs ({n_mc_top} runs each)...")

mc_top_results = []
for sku_id in tqdm(top_skus, desc="MC Top SKUs"):
    result = run_monte_carlo_sku(sku_id, n_runs=n_mc_top, use_xgb=True)
    if result:
        mc_top_results.append(result)

mc_top_df = pd.DataFrame(mc_top_results)
print(f"Completed: {len(mc_top_df)} top SKUs")

# Run Monte Carlo for other SKUs
print(f"\n[9.2] Monte Carlo for Other SKUs ({n_mc_other} runs each)...")

max_other_skus = 200
if len(other_skus) > max_other_skus:
    print(f"  Sampling {max_other_skus} out of {len(other_skus)} SKUs...")
    other_skus_sample = np.random.choice(other_skus, max_other_skus, replace=False)
else:
    other_skus_sample = other_skus

mc_other_results = []
for sku_id in tqdm(other_skus_sample, desc="MC Other SKUs"):
    result = run_monte_carlo_sku(sku_id, n_runs=n_mc_other, use_xgb=True)
    if result:
        mc_other_results.append(result)

mc_other_df = pd.DataFrame(mc_other_results)
print(f"Completed: {len(mc_other_df)} other SKUs")

# Combine Monte Carlo results
mc_combined_df = pd.concat([mc_top_df, mc_other_df], ignore_index=True)

print(f"\nTotal Monte Carlo results: {len(mc_combined_df)} SKUs")

# ============================================================================
# 10. BUSINESS IMPACT FOR j+7 HORIZON
# ============================================================================
print("\n" + "=" * 80)
print("[10] BUSINESS IMPACT ESTIMATION - HORIZON j+7")
print("=" * 80)

# Technical metrics for j+7
print("\n[10.1] Calculating Technical Metrics for j+7...")

forecast_models_j7 = {
    'Naïve (j-1)': 'Baseline_Naive',
    'Naïve Season (j-7)': 'Baseline_Naive_Season',
    'Moving Avg (7d)': 'Baseline_MA7',
    'Dataset Forecast': 'Baseline_Dataset',
    'XGBoost ML (j+7)': 'Pred_XGB_j7'
}

technical_metrics_j7_list = []

for model_name, forecast_col in forecast_models_j7.items():
    if forecast_col not in test_df_clean.columns:
        continue

    y_true = test_df_clean['Units_Sold_j7']
    y_pred = test_df_clean[forecast_col]

    metrics = calculate_metrics(y_true, y_pred, model_name)
    if metrics:
        metrics['SMAPE'] = calculate_smape(y_true.values, y_pred.values)
        technical_metrics_j7_list.append(metrics)

technical_metrics_j7_df = pd.DataFrame(technical_metrics_j7_list)

print("\nTechnical Metrics (j+7):")
print(technical_metrics_j7_df[['Model', 'RMSE', 'SMAPE']].to_string(index=False))

# Aggregate KPIs for j+7
print("\n[10.2] Aggregating KPIs for j+7...")

def aggregate_kpis_j7(sim_df, model_name):
    if len(sim_df) == 0:
        return None

    total_demand_all = sim_df['total_demand'].sum()
    if total_demand_all == 0:
        return None

    sim_df = sim_df.copy()
    sim_df['weight'] = sim_df['total_demand'] / total_demand_all

    weighted_fill_rate = (sim_df['fill_rate'] * sim_df['weight']).sum()
    weighted_stockout_rate = (sim_df['stockout_rate'] * sim_df['weight']).sum()

    return {
        'Model': model_name,
        'Fill_Rate_%': weighted_fill_rate,
        'Stockout_Rate_%': weighted_stockout_rate,
        'Holding_Cost_€': sim_df['holding_cost'].sum(),
        'Stockout_Cost_€': sim_df['stockout_cost'].sum(),
        'Total_Cost_€': sim_df['total_cost'].sum()
    }

# Create comparison table for j+7
business_kpis_j7_list = []

# Note: Baselines use same simulations as j+1
from copy import deepcopy
business_kpis_j7_list.append(aggregate_kpis_j7(xgb_sim_df, 'Naïve (j-1)'))
business_kpis_j7_list.append(aggregate_kpis_j7(xgb_sim_df, 'Naïve Season (j-7)'))
business_kpis_j7_list.append(aggregate_kpis_j7(xgb_sim_df, 'Moving Avg (7d)'))
business_kpis_j7_list.append(aggregate_kpis_j7(xgb_sim_df, 'Dataset Forecast'))
business_kpis_j7_list.append(aggregate_kpis_j7(xgb_j7_sim_df, 'XGBoost ML (j+7)'))

business_kpis_j7_list = [x for x in business_kpis_j7_list if x is not None]
business_kpis_j7_df = pd.DataFrame(business_kpis_j7_list)

# Create comparison table j+7
comparison_j7_table = technical_metrics_j7_df.merge(
    business_kpis_j7_df,
    on='Model',
    how='outer'
)

comparison_j7_columns = [
    'Model', 'RMSE', 'SMAPE', 'Fill_Rate_%', 'Stockout_Rate_%',
    'Holding_Cost_€', 'Stockout_Cost_€', 'Total_Cost_€', 'WAPE'
]

comparison_j7_table = comparison_j7_table[comparison_j7_columns]

print("\nComparison Table (j+7):")
print(comparison_j7_table.to_string(index=False))

# ============================================================================
# 11. SUMMARY
# ============================================================================
print("\n" + "=" * 80)
print("BLOCK D COMPLETE")
print("=" * 80)

print("\nKey Outputs Created:")
print("  xgb_sim_df - XGBoost j+1 simulation results")
print("  xgb_j7_sim_df - XGBoost j+7 simulation results")
print("  mc_combined_df - Monte Carlo simulation results")
print("  comparison_j7_table - j+7 comparison table")

print("\nReady for Block E: Business Impact & Export")